(in-package :ometa)
(declaim (optimize (safety 3) (debug 3)))

(defun ometa-compile (form package)
  (let ((*package* package))
    (labels ((rec (form)
               (case (first form)
                 ((prod :rule) (destructuring-bind (prod name locals body) form
                                 `(defmethod ,(intern (string-upcase name) package) ((o ,*ometa-compiler-target*) arg)
                                    (let ((*posn* (input-position (input-stream o))))
                                      (let ,(loop for l in locals collect (intern (string-upcase (symbol-name l)))) ,(rec body))))))
                 ((or :or) `(ometa-apply o 'oOr (list ,@(loop for f in (cdr form) collect `(lambda (o nullarg) ,(rec f))))))
                 ((and :and) `(ometa-apply o 'oAnd (list ,@(loop for f in (cdr form) collect `(lambda (o nullarg) ,(rec f))))))
                 ((many :many)  `(ometa-apply o 'oMany (lambda (o nullarg) ,(rec (second form)))))
                 ((many1 :many1) `(ometa-apply o 'oMany1 (lambda (o nullarg) ,(rec (second form)))))
                 ((not :not) `(ometa-apply o 'oNot (lambda (o nullarg) ,(rec (second form)))))
                 ((:lookahead) `(ometa-apply o 'oNot (lambda (o nullarg) (ometa-apply o 'oNot (lambda (o nullarg) ,(rec (second form)))))))
                 ((apply :apply :app) (destructuring-bind (app name . args) form
                                        `(ometa-apply o
                                                      ',(if (stringp name) (intern (string-upcase name) package) name)
                                                      ,(if (null args)
                                                           nil
                                                           `(list ,@(loop for a in args
                                                                       collect (if (consp a)
                                                                                   (ecase (first a)
                                                                                     (:app (rec a))
                                                                                     (:string (second a))
                                                                                     (:character (second a))
                                                                                     (:symbol (intern (second a))))
                                                                                   (intern (string-upcase a) package))))))))
                 ((assign :assign :set) `(let ((v ,(rec (if (equal (third form) `(:app :anything)) `(:loadarg) (third form)))))
                                           (setf ,(intern (string-upcase (second form)) package) v)
                                           v))
                 ((action :action :act) (if (stringp (second form)) (read-from-string (second form)) (rec (second form))))
                 ((pred :pred)  `(ometa-apply o 'oPred ,(read-from-string (second (second form)))))
                 ((loadarg :loadarg) `(pop arg))
                 ((:string) (second form))
                 (otherwise (warn "other ~A" form) form))))
      (rec form))))
